"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[18631],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=u(n),d=r,m=h["".concat(l,".").concat(d)]||h[d]||p[d]||i;return n?a.createElement(m,o(o({ref:t},c),{},{components:n})):a.createElement(m,o({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var u=2;u<i;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},72411:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var a=n(87462),r=(n(67294),n(3905));const i={slug:"zero2hero-func-02",title:"\ud83d\ude80 | Durable Entities Walkthrough",authors:["davidjusto"],draft:!1,hide_table_of_contents:!1,toc_min_heading_level:2,toc_max_heading_level:3,keywords:["azure","functions","containerapps","serverless","concepts"],image:"./img/zero-to-hero-david.png",description:"Durable Entities are a special type of Azure Functions that allow you to implement stateful objects in a serverless environment.",tags:["serverless-september","zero-to-hero","azure-functions","azure-container-apps","dapr"]},o=void 0,s={permalink:"/Cloud-Native/blog/zero2hero-func-02",source:"@site/blog/zero-to-hero/2022-09-06-azurefunctions.md",title:"\ud83d\ude80 | Durable Entities Walkthrough",description:"Durable Entities are a special type of Azure Functions that allow you to implement stateful objects in a serverless environment.",date:"2022-09-06T00:00:00.000Z",formattedDate:"September 6, 2022",tags:[{label:"serverless-september",permalink:"/Cloud-Native/blog/tags/serverless-september"},{label:"zero-to-hero",permalink:"/Cloud-Native/blog/tags/zero-to-hero"},{label:"azure-functions",permalink:"/Cloud-Native/blog/tags/azure-functions"},{label:"azure-container-apps",permalink:"/Cloud-Native/blog/tags/azure-container-apps"},{label:"dapr",permalink:"/Cloud-Native/blog/tags/dapr"}],readingTime:7.465,hasTruncateMarker:!1,authors:[{name:"David Justo",title:"Software Engineer @Microsoft",url:"https://github.com/davidmrdavid",imageURL:"https://github.com/davidmrdavid.png",key:"davidjusto"}],frontMatter:{slug:"zero2hero-func-02",title:"\ud83d\ude80 | Durable Entities Walkthrough",authors:["davidjusto"],draft:!1,hide_table_of_contents:!1,toc_min_heading_level:2,toc_max_heading_level:3,keywords:["azure","functions","containerapps","serverless","concepts"],image:"./img/zero-to-hero-david.png",description:"Durable Entities are a special type of Azure Functions that allow you to implement stateful objects in a serverless environment.",tags:["serverless-september","zero-to-hero","azure-functions","azure-container-apps","dapr"]},prevItem:{title:"06. Functions for .NET Devs",permalink:"/Cloud-Native/blog/06-functions-dotnet"},nextItem:{title:"\ud83d\ude80 | Go Cloud-Native with ACA",permalink:"/Cloud-Native/blog/zero2hero-aca-01"}},l={image:n(29152).Z,authorsImageUrls:[void 0]},u=[{value:"What We&#39;ll Cover",id:"what-well-cover",level:2},{value:"Entities 101: Some Background",id:"entities-101-some-background",level:2},{value:"Entities 102: The programming model",id:"entities-102-the-programming-model",level:2},{value:"Entities for a micro-blogging platform",id:"entities-for-a-micro-blogging-platform",level:2},{value:"Defining Entity",id:"defining-entity",level:3},{value:"Interacting with Entity",id:"interacting-with-entity",level:3}],c={toc:u};function p(e){let{components:t,...i}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("head",null,(0,r.kt)("meta",{name:"twitter:url",content:"https://azure.github.io/Cloud-Native/blog/zero2hero-func-02"}),(0,r.kt)("meta",{name:"twitter:title",content:"#ZeroToHero: A Walkthrough of Durable Entities"}),(0,r.kt)("meta",{name:"twitter:description",content:"#ZeroToHero: A Walkthrough of Durable Entities"}),(0,r.kt)("meta",{name:"twitter:image",content:"https://azure.github.io/Cloud-Native/img/banners/serverless-zero2hero.png"}),(0,r.kt)("meta",{name:"twitter:card",content:"summary_large_image"}),(0,r.kt)("meta",{name:"twitter:creator",content:"@nitya"}),(0,r.kt)("meta",{name:"twitter:site",content:"@AzureAdvocates"}),(0,r.kt)("link",{rel:"canonical",href:"https://techcommunity.microsoft.com/t5/apps-on-azure-blog/a-walkthrough-of-durable-entities/ba-p/3616832"})),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Welcome to ",(0,r.kt)("inlineCode",{parentName:"p"},"Day 6")," of #30DaysOfServerless!"),(0,r.kt)("p",null,"Today, we have a special set of posts from our ",(0,r.kt)("a",{parentName:"p",href:"/serverless-september/ZeroToHero"},"Zero To Hero \ud83d\ude80")," initiative, featuring blog posts authored by our Product Engineering teams for #ServerlessSeptember. ",(0,r.kt)("em",{parentName:"p"},"Posts were originally published on the ",(0,r.kt)("a",{parentName:"em",href:"https://techcommunity.microsoft.com/t5/apps-on-azure-blog/a-walkthrough-of-durable-entities/ba-p/3616832?WT.mc_id=javascript-99907-cxa"},"Apps on Azure")," blog on Microsoft Tech Community.")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"what-well-cover"},"What We'll Cover"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"What are Durable Entities"),(0,r.kt)("li",{parentName:"ul"},"Some Background"),(0,r.kt)("li",{parentName:"ul"},"A Programming Model"),(0,r.kt)("li",{parentName:"ul"},"Entities for a Micro-Blogging Platform")),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(29152).Z,width:"1600",height:"672"})),(0,r.kt)("hr",null),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/azure/azure-functions/durable/durable-functions-entities?tabs=csharp&WT.mc_id=javascript-99907-cxa"},"Durable Entities")," are a special type of Azure Function that allow you to implement stateful objects in a serverless environment. They make it easy to introduce stateful components to your app without needing to manually persist data to external storage, so you can focus on your business logic. We\u2019ll demonstrate their power with a real-life example in the last section."),(0,r.kt)("h2",{id:"entities-101-some-background"},"Entities 101: Some Background"),(0,r.kt)("p",null,"Programming Durable Entities feels a lot like object-oriented programming, except that these \u201cobjects\u201d exist in a distributed system. Like objects, each Entity instance has a unique identifier, i.e. an entity ID that can be used to read and manipulate their internal state. Entities define a list of operations that constrain how their internal state is managed, like an object interface."),(0,r.kt)("p",null,"Some experienced readers may realize that Entities sound a lot like an implementation of the Actor Pattern. For a discussion of the relationship between Entities and Actors, please refer to ",(0,r.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/azure/azure-functions/durable/durable-functions-entities?tabs=csharp#comparison-with-virtual-actors"},"this documentation"),"."),(0,r.kt)("p",null,"Entities are a part of the Durable Functions Extension, an extension of Azure Functions that empowers programmers with stateful abstractions for serverless, such as Orchestrations (i.e. workflows)."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/azure/azure-functions/durable/durable-functions-overview?tabs=csharp"},"Durable Functions")," is available in most Azure Functions runtime environments: .NET, Node.js, Python, PowerShell, and Java (preview). For this article, we\u2019ll focus on the C# experience, but note that Entities are also available in Node.js and Python; their availability in other languages is underway."),(0,r.kt)("h2",{id:"entities-102-the-programming-model"},"Entities 102: The programming model"),(0,r.kt)("p",null,"Imagine you want to implement a simple Entity that just counts things. Its interface allows you to get the current count, add to the current count, and to reset the count to zero."),(0,r.kt)("p",null,"If you implement this in an object-oriented way, you\u2019d probably define a class (say \u201cCounter\u201d) with a method to get the current count (say \u201cCounter.Get\u201d), another to add to the count (say \u201cCounter.Add\u201d), and another to reset the count (say \u201cCounter.Reset\u201d). Well, the implementation of an Entity in C# is not that different from this sketch:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'[JsonObject(MemberSerialization.OptIn)] \npublic class Counter \n{ \n    [JsonProperty("value")] \n    public int Value { get; set; } \n \n    public void Add(int amount)  \n    { \n        this.Value += amount; \n    } \n\n    public Task Reset()  \n    { \n        this.Value = 0; \n        return Task.CompletedTask; \n    } \n \n    public Task<int> Get()  \n    { \n        return Task.FromResult(this.Value); \n    } \n    [FunctionName(nameof(Counter))] \n    public static Task Run([EntityTrigger] IDurableEntityContext ctx) \n        => ctx.DispatchAsync<Counter>(); \n\n} \n')),(0,r.kt)("p",null,"We\u2019ve defined a class named Counter, with an internal count stored in the variable \u201cValue\u201d which is manipulated through the \u201cAdd\u201d and \u201cReset\u201d methods, and which can be read via \u201cGet\u201d."),(0,r.kt)("p",null,"The \u201cRun\u201d method is simply boilerplate required for the Azure Functions framework to interact with the object we\u2019ve defined \u2013 it\u2019s the method that the framework calls internally when it needs to load the Entity object. When ",(0,r.kt)("inlineCode",{parentName:"p"},"DispatchAsync")," is called, the Entity and its corresponded state (the last count in \u201cValue\u201d) is loaded from storage. Again, this is mostly just boilerplate: your Entity\u2019s business logic lies in the rest of the class."),(0,r.kt)("p",null,"Finally, the Json annotation on top of the class and the Value field tells the Durable Functions framework that the \u201cValue\u201d field is to be durably persisted as part of the durable state on each Entity invocation. If you were to annotate other class variables with JsonProperty, they would also become part of the managed state."),(0,r.kt)("h2",{id:"entities-for-a-micro-blogging-platform"},"Entities for a micro-blogging platform"),(0,r.kt)("p",null,"We\u2019ll try to implement a simple micro-blogging platform, a la Twitter. Let\u2019s call it \u201cChirper\u201d. In Chirper, users write chirps (i.e tweets), they can follow, and unfollow other users, and they can read the chirps of users they follow."),(0,r.kt)("h3",{id:"defining-entity"},"Defining Entity"),(0,r.kt)("p",null,"Just like in OOP, it\u2019s useful to begin by identifying what are the stateful agents of this scenario. In this case, users have state (who they follow and their chirps), and chirps have state in the form of their content. So, we could model these stateful agents as Entities!"),(0,r.kt)("p",null,"Below is a potential way to implement a User for Chirper as an Entity:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"  [JsonObject(MemberSerialization = MemberSerialization.OptIn)] \n  public class User: IUser  \n  { \n      [JsonProperty] \n      public List<string> FollowedUsers { get; set; }  = new List<string>(); \n\n      public void Add(string user) \n      { \n          FollowedUsers.Add(user); \n      } \n\n      public void Remove(string user) \n      { \n          FollowedUsers.Remove(user); \n      } \n\n      public Task<List<string>> Get() \n      { \n          return Task.FromResult(FollowedUsers); \n      } \n      // note: removed boilerplate \u201cRun\u201d method, for conciseness. \n  } \n")),(0,r.kt)("p",null,"In this case, our Entity\u2019s internal state is stored in \u201cFollowedUsers\u201d which is an array of accounts followed by this user. The operations exposed by this entity allow clients to read and modify this data: it can be read by \u201cGet\u201d, a new follower can be added via \u201cAdd\u201d, and a user can be unfollowed via \u201cRemove\u201d."),(0,r.kt)("p",null,"With that, we\u2019ve modeled a Chirper\u2019s user as an Entity! Recall that Entity instances each has a unique ID, so we can consider that unique ID to correspond to a specific user account."),(0,r.kt)("p",null,"What about chirps? Should we represent them as Entities as well? That would certainly be valid. However, we would then need to create a mapping between an entity ID and every chirp entity ID that this user wrote."),(0,r.kt)("p",null,"For demonstration purposes, a simpler approach would be to create an Entity that stores the list of all chirps authored by a given user; call it UserChirps. Then, we could fix each User Entity to share the same entity ID as its corresponding UserChirps Entity, making client operations easier."),(0,r.kt)("p",null,"Below is a simple implementation of UserChirps:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"  [JsonObject(MemberSerialization = MemberSerialization.OptIn)] \n  public class UserChirps : IUserChirps \n  { \n      [JsonProperty] \n      public List<Chirp> Chirps { get; set; } = new List<Chirp>(); \n\n      public void Add(Chirp chirp) \n      { \n          Chirps.Add(chirp); \n      } \n\n      public void Remove(DateTime timestamp) \n      { \n          Chirps.RemoveAll(chirp => chirp.Timestamp == timestamp); \n      } \n\n      public Task<List<Chirp>> Get() \n      { \n          return Task.FromResult(Chirps); \n      } \n\n      // Omitted boilerplate \u201cRun\u201d function \n  } \n")),(0,r.kt)("p",null,"Here, our state is stored in Chirps, a list of user posts. Our operations are the same as before: Get, Read, and Add. It\u2019s the same pattern as before, but we\u2019re representing different data."),(0,r.kt)("p",null,"To put it all together, let\u2019s set up Entity clients to generate and manipulate these Entities according to some REST API."),(0,r.kt)("h3",{id:"interacting-with-entity"},"Interacting with Entity"),(0,r.kt)("p",null,"Before going there, let\u2019s talk briefly about how you can interact with an Entity. Entity interactions take one of two forms -- ",(0,r.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/azure/azure-functions/durable/durable-functions-entities?tabs=csharp#access-entities"},"calls and signals"),":"),(0,r.kt)("p",null,"Calling an entity is a two-way communication. You send an operation message to the entity and then wait for the response message before you continue. The response can be a result value or an error.\nSignaling an entity is a one-way (fire-and-forget) communication. You send an operation message but don\u2019t wait for a response. You have the reassurance that the message will be delivered eventually, but you don\u2019t know when and don\u2019t know what the response is.\nFor example, when you read the state of an Entity, you are performing a \u201ccall\u201d interaction. When you record that a user has followed another, you may choose to simply signal it."),(0,r.kt)("p",null,"Now say user with a given userId (say \u201cdurableFan99\u201d ) wants to post a chirp. For this, you can write an HTTP endpoint to signal the UserChips entity to record that chirp. We can leverage the HTTP Trigger functionality from Azure Functions and pair it with an entity client binding that signals the Add operation of our Chirp Entity:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'[FunctionName("UserChirpsPost")] \npublic static async Task<HttpResponseMessage> UserChirpsPost( \n    [HttpTrigger(AuthorizationLevel.Function, "post", Route = "user/{userId}/chirps")] \n    HttpRequestMessage req, \n    DurableClient] IDurableClient client, \n    ILogger log,  \n    string userId) \n    { \n        Authenticate(req, userId); \n        var chirp = new Chirp() \n        { \n            UserId = userId, \n            Timestamp = DateTime.UtcNow, \n            Content = await req.Content.ReadAsStringAsync(), \n        }; \n        await client.SignalEntityAsync<IUserChirps>(userId, x => x.Add(chirp)); \n        return req.CreateResponse(HttpStatusCode.Accepted, chirp); \n    } \n')),(0,r.kt)("p",null,"Following the same pattern as above, to get all the chirps from a user, you could read the status of your Entity via ",(0,r.kt)("inlineCode",{parentName:"p"},"ReadEntityStateAsync"),", which follows the call-interaction pattern as your client expects a response:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'[FunctionName("UserChirpsGet")] \npublic static async Task<HttpResponseMessage> UserChirpsGet( \n  [HttpTrigger(AuthorizationLevel.Function, "get", Route = "user/{userId}/chirps")] HttpRequestMessage req, \n  [DurableClient] IDurableClient client, \n  ILogger log, \n  string userId) \n  { \n\n      Authenticate(req, userId); \n      var target = new EntityId(nameof(UserChirps), userId); \n      var chirps = await client.ReadEntityStateAsync<UserChirps>(target); \n      return chirps.EntityExists \n            ? req.CreateResponse(HttpStatusCode.OK, chirps.EntityState.Chirps) \n            : req.CreateResponse(HttpStatusCode.NotFound); \n  } \n')),(0,r.kt)("p",null,"And there you have it! To play with a complete implementation of Chirper, you can try out our sample in the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Azure/azure-functions-durable-extension/tree/dev/samples/entitites-csharp/Chirper"},"Durable Functions extension repo"),".  "),(0,r.kt)("p",null,"Thank you!"),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Thanks for following along, and we hope you find Entities as useful as we do! If you have questions or feedback, please file issues in the repo above or tag us ",(0,r.kt)("a",{parentName:"p",href:"https://twitter.com/AzureFunctions"},"@AzureFunctions")," on Twitter")))}p.isMDXComponent=!0},29152:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/zero-to-hero-david-2236e6d82fe0064fef5a652807264fd7.png"}}]);
"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[10876],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>m});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},u=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=p(a),m=i,h=d["".concat(s,".").concat(m)]||d[m]||c[m]||r;return a?n.createElement(h,l(l({ref:t},u),{},{components:a})):n.createElement(h,l({ref:t},u))}));function m(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},38619:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var n=a(87462),i=(a(67294),a(3905));const r={date:"2023-10-10T09:00",slug:"scaling-intelligent-apps-on-azure-kubernetes-services-1",title:"2-5. Scaling Intelligent Apps on Azure Kubernetes Services (1)",authors:["cnteam"],draft:!1,hide_table_of_contents:!1,toc_min_heading_level:2,toc_max_heading_level:3,keywords:["Cloud","Data","AI","AI/ML","intelligent apps","cloud-native","30-days","enterprise apps","digital experiences","app modernization","serverless","ai apps","data"],image:"https://azure.github.io/Cloud-Native/img/ogImage.png",description:"Explore the power of multi-model databases for Intelligent Apps and their integration with Azure Cosmos DB and Azure Kubernetes Service (AKS).",tags:["Build-Intelligent-Apps","30-days-of-IA","learn-live","hack-together","community-buzz","ask-the-expert","azure-kubernetes-service","azure-functions","azure-openai","azure-container-apps","azure-cosmos-db","github-copilot","github-codespaces","github-actions"]},l=void 0,o={permalink:"/Cloud-Native/30DaysOfIA/scaling-intelligent-apps-on-azure-kubernetes-services-1",source:"@site/blog-30daysofIA/2023-10-10/scaling-intelligent-apps-on-azure-kubernetes-services-1.md",title:"2-5. Scaling Intelligent Apps on Azure Kubernetes Services (1)",description:"Explore the power of multi-model databases for Intelligent Apps and their integration with Azure Cosmos DB and Azure Kubernetes Service (AKS).",date:"2023-10-10T09:00:00.000Z",formattedDate:"October 10, 2023",tags:[{label:"Build-Intelligent-Apps",permalink:"/Cloud-Native/30DaysOfIA/tags/build-intelligent-apps"},{label:"30-days-of-IA",permalink:"/Cloud-Native/30DaysOfIA/tags/30-days-of-ia"},{label:"learn-live",permalink:"/Cloud-Native/30DaysOfIA/tags/learn-live"},{label:"hack-together",permalink:"/Cloud-Native/30DaysOfIA/tags/hack-together"},{label:"community-buzz",permalink:"/Cloud-Native/30DaysOfIA/tags/community-buzz"},{label:"ask-the-expert",permalink:"/Cloud-Native/30DaysOfIA/tags/ask-the-expert"},{label:"azure-kubernetes-service",permalink:"/Cloud-Native/30DaysOfIA/tags/azure-kubernetes-service"},{label:"azure-functions",permalink:"/Cloud-Native/30DaysOfIA/tags/azure-functions"},{label:"azure-openai",permalink:"/Cloud-Native/30DaysOfIA/tags/azure-openai"},{label:"azure-container-apps",permalink:"/Cloud-Native/30DaysOfIA/tags/azure-container-apps"},{label:"azure-cosmos-db",permalink:"/Cloud-Native/30DaysOfIA/tags/azure-cosmos-db"},{label:"github-copilot",permalink:"/Cloud-Native/30DaysOfIA/tags/github-copilot"},{label:"github-codespaces",permalink:"/Cloud-Native/30DaysOfIA/tags/github-codespaces"},{label:"github-actions",permalink:"/Cloud-Native/30DaysOfIA/tags/github-actions"}],readingTime:16.845,hasTruncateMarker:!1,authors:[{name:"It's 30DaysOfIA",title:"BuildIA Content Team",url:"https://azure.github.io/Cloud-Native/Build-IA/",imageURL:"https://azure.github.io/Cloud-Native/img/logo-ms-cloud-native.png",key:"cnteam"}],frontMatter:{date:"2023-10-10T09:00",slug:"scaling-intelligent-apps-on-azure-kubernetes-services-1",title:"2-5. Scaling Intelligent Apps on Azure Kubernetes Services (1)",authors:["cnteam"],draft:!1,hide_table_of_contents:!1,toc_min_heading_level:2,toc_max_heading_level:3,keywords:["Cloud","Data","AI","AI/ML","intelligent apps","cloud-native","30-days","enterprise apps","digital experiences","app modernization","serverless","ai apps","data"],image:"https://azure.github.io/Cloud-Native/img/ogImage.png",description:"Explore the power of multi-model databases for Intelligent Apps and their integration with Azure Cosmos DB and Azure Kubernetes Service (AKS).",tags:["Build-Intelligent-Apps","30-days-of-IA","learn-live","hack-together","community-buzz","ask-the-expert","azure-kubernetes-service","azure-functions","azure-openai","azure-container-apps","azure-cosmos-db","github-copilot","github-codespaces","github-actions"]},prevItem:{title:"2-6. Scaling Intelligent Apps on Azure Kubernetes Services (2)",permalink:"/Cloud-Native/30DaysOfIA/scaling-intelligent-apps-on-azure-kubernetes-services-2"},nextItem:{title:"2-4. Powering Intelligent Apps with Azure Cosmos DB (2)",permalink:"/Cloud-Native/30DaysOfIA/powering-intelligent-apps-with-azure-cosmos-db-2"}},s={authorsImageUrls:[void 0]},p=[{value:"What We&#39;ll Cover:",id:"what-well-cover",level:2},{value:"Scaling Intelligent Apps on Azure Kubernetes Services (1)\u202f",id:"scaling-intelligent-apps-on-azure-kubernetes-services-1",level:2},{value:"Mastering Azure Kubernetes Services (AKS) for Intelligent App",id:"mastering-azure-kubernetes-services-aks-for-intelligent-app",level:3},{value:"Prerequisites",id:"prerequisites",level:4},{value:"Solution Architecture",id:"solution-architecture",level:4},{value:"Configuring AKS for Dynamic App Scaling",id:"configuring-aks-for-dynamic-app-scaling",level:4},{value:"Setting Up the Cluster Autoscaler in AKS",id:"setting-up-the-cluster-autoscaler-in-aks",level:5},{value:"How the Cluster Autoscaler Dynamically Scales Resources",id:"how-the-cluster-autoscaler-dynamically-scales-resources",level:5},{value:"Configuring the Horizontal Pod Autoscaler",id:"configuring-the-horizontal-pod-autoscaler",level:5},{value:"Ensuring High Availability with Azure Load Balancer and AKS",id:"ensuring-high-availability-with-azure-load-balancer-and-aks",level:4},{value:"Availability Zones in AKS",id:"availability-zones-in-aks",level:5},{value:"Maintaining Service During Voluntary Disruptions Using Disruption Budgets",id:"maintaining-service-during-voluntary-disruptions-using-disruption-budgets",level:5},{value:"Configuring Azure Load Balancer in AKS for High Availability",id:"configuring-azure-load-balancer-in-aks-for-high-availability",level:5},{value:"Exercise",id:"exercise",level:2},{value:"Next Steps",id:"next-steps",level:2}],u={toc:p};function c(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("head",null,(0,i.kt)("meta",{property:"og:url",content:"https://azure.github.io/cloud-native/30daysofia/scaling-intelligent-apps-on-azure-kubernetes-services-1"}),(0,i.kt)("meta",{property:"og:type",content:"website"}),(0,i.kt)("meta",{property:"og:title",content:"Build Intelligent Apps!| Build AI Apps On Azure"}),(0,i.kt)("meta",{property:"og:description",content:"Dive into how to harness AKS\u2019 powerful features like auto-scaling and high availability to manage variable workloads and maintain continuous service."}),(0,i.kt)("meta",{property:"og:image",content:"https://azure.github.io/Cloud-Native/img/ogImage.png"}),(0,i.kt)("meta",{name:"twitter:url",content:"https://azure.github.io/Cloud-Native/30daysofIA/scaling-intelligent-apps-on-azure-kubernetes-services-1"}),(0,i.kt)("meta",{name:"twitter:title",content:"Build Intelligent Apps! | Build AI Apps On Azure"}),(0,i.kt)("meta",{name:"twitter:description",content:"2-5.Dive into how to harness AKS\u2019 powerful features like auto-scaling and high availability to manage variable workloads and maintain continuous service."}),(0,i.kt)("meta",{name:"twitter:image",content:"https://azure.github.io/Cloud-Native/img/ogImage.png"}),(0,i.kt)("meta",{name:"twitter:card",content:"summary_large_image"}),(0,i.kt)("meta",{name:"twitter:creator",content:"@devanshidiaries"}),(0,i.kt)("meta",{name:"twitter:site",content:"@AzureAdvocates"}),(0,i.kt)("link",{rel:"canonical",href:"https://azure.github.io/Cloud-Native/30daysofIA/scaling-intelligent-apps-on-azure-kubernetes-services-1"})),(0,i.kt)("p",null,"In this article, dive into how to harness AKS\u2019 powerful features like auto-scaling and high availability to manage variable workloads and monitoring to maintain continuous service."),(0,i.kt)("h2",{id:"what-well-cover"},"What We'll Cover:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Deploying on Azure Kubernetes Service (AKS) "),(0,i.kt)("li",{parentName:"ul"},"Configuring AKS for dynamic application scaling"),(0,i.kt)("li",{parentName:"ul"},"Ensuring High Availability with Azure Load Balancer and AKS")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"image of node settings in Azure portal",src:a(90615).Z,width:"624",height:"380"})),(0,i.kt)("h2",{id:"scaling-intelligent-apps-on-azure-kubernetes-services-1"},"Scaling Intelligent Apps on Azure Kubernetes Services (1)\u202f"),(0,i.kt)("p",null,"In the ",(0,i.kt)("a",{parentName:"p",href:"https://azure.github.io/Cloud-Native/30daysofIA/build-your-first-intelligent-app-with-azure-ai-and-aks-1"},"first topic of this week"),", we explored how to use Azure Cognitive Services for Vision within Azure Kubernetes Service (AKS) to create an Intelligent App capable of analyzing images and extracting valuable data through optical character recognition (OCR). The week\u2019s ",(0,i.kt)("a",{parentName:"p",href:"https://azure.github.io/Cloud-Native/30DaysOfIA/build-your-first-intelligent-app-with-azure-ai-and-aks-2"},"second article"),", focused on the advantages of Azure Cosmos DB, highlighting its multi-model database and ability to handle diverse data resulting from OCR analysis in our Intelligent App. "),(0,i.kt)("p",null,"In this third topic, we\u2019ll configure ",(0,i.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/azure/aks/?WT.mc_id=javascript-99907-ninarasi"},"Azure Kubernetes Service (AKS)")," to manage varying workloads and smoothly scale our Intelligent App, ensuring it can handle intense and fluctuating workloads without compromising performance or availability. "),(0,i.kt)("h3",{id:"mastering-azure-kubernetes-services-aks-for-intelligent-app"},"Mastering Azure Kubernetes Services (AKS) for Intelligent App"),(0,i.kt)("p",null,"At the core of the Azure ecosystem lies AKS. It plays a crucial role in optimizing application performance and efficient resource use. We can deploy, manage, and scale applications across different environments by precisely orchestrating containerized workloads.  "),(0,i.kt)("p",null,"AKS offers several robust features that help applications scale smoothly and stay available even during heavy demand, including the following: "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("a",{parentName:"li",href:"https://learn.microsoft.com/en-us/azure/aks/cluster-autoscaler?WT.mc_id=javascript-99907-ninarasi"},"cluster autoscaler")," adjusts the number of nodes in your cluster based on how much work you have. This way, it uses resources efficiently and keeps costs in check.  "),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("a",{parentName:"li",href:"https://azure.microsoft.com/en-ca/products/load-balancer?WT.mc_id=javascript-99907-ninarasi"},"Azure Load Balancer")," is created automatically with AKS and acts like an intelligent traffic controller. It ensures incoming network traffic is distributed well across your cluster\u2019s nodes, optimizing resource usage.  ")),(0,i.kt)("p",null,"Together, these features give your applications a solid base to handle different workloads and keep running nonstop.  "),(0,i.kt)("p",null,"The following sections provide hands-on demonstrations of setting up, monitoring, and optimizing AKS to drive application efficiency and performance"),(0,i.kt)("h4",{id:"prerequisites"},"Prerequisites"),(0,i.kt)("p",null,"To follow this tutorial, ensure you have the following:\u202f "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Read through the ",(0,i.kt)("a",{parentName:"li",href:"https://azure.github.io/Cloud-Native/30daysofIA/build-your-first-intelligent-app-with-azure-ai-and-aks-1"},"first")," and ",(0,i.kt)("a",{parentName:"li",href:"https://azure.github.io/Cloud-Native/30DaysOfIA/powering-intelligent-apps-with-azure-cosmos-db-1"},"second")," topics of this week"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.python.org/downloads/"},"Python 3.7")," or later installed\u202f "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://code.visualstudio.com/download"},"VS Code")," or another integrated development environment (IDE) for writing Python code\u202f "),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/contentlab-io/Microsoft-Powering-Intelligent-Apps-with-Cosmos-DB-and-Azure-Kubernetes-Service/tree/main/PartTwo_IntelligentApp_After"},"sample Python application")," from the second article of this series downloaded. Open the project before getting started. "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://pip.pypa.io/en/stable/installing/"},"pip"),", the package manager for Python, installed\u202f "),(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("a",{parentName:"li",href:"https://azure.microsoft.com/free/?WT.mc_id=javascript-99907-ninarasi"},"free Azure account"),". Sign up if you don\u2019t have one yet.\u202f"),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("a",{parentName:"li",href:"https://learn.microsoft.com/cli/azure/install-azure-cli?WT.mc_id=javascript-99907-ninarasi"},"Azure command-line interface")," (CLI)")),(0,i.kt)("p",null,"Check out the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/contentlab-io/Microsoft-Scaling-Intelligent-Apps-on-Azure-Kubernetes-Services/tree/main/Microsoft_21_Code/Deployment"},"complete project code")," for a preview of the final project."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Complete the ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"https://aka.ms/fallforIA/apps-csc"},"Apps Cloud Skills Challenge"))," to build on your AKS app dev skills.  "),(0,i.kt)("p",{parentName:"admonition"},"To start with the basics for developing\u202f",(0,i.kt)("a",{parentName:"p",href:"https://azure.microsoft.com/en-us/products/kubernetes-service/?WT.mc_id=javascript-99907-ninarasi"},"Kubernetes"),"\u202fapplications, explore\u202f",(0,i.kt)("a",{parentName:"p",href:"https://azure.github.io/Cloud-Native/cnny-2023"},"#30DaysOfCloudNative"),". ")),(0,i.kt)("h4",{id:"solution-architecture"},"Solution Architecture"),(0,i.kt)("p",null,"The image below shows the architecture of the solution we\u2019re aiming for in this article."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Image of solution architecture",src:a(17325).Z,width:"624",height:"403"})),(0,i.kt)("h4",{id:"configuring-aks-for-dynamic-app-scaling"},"Configuring AKS for Dynamic App Scaling"),(0,i.kt)("p",null,"The cluster autoscaler and Kubernetes Horizontal Pod Autoscaling (HPA) are essential in achieving dynamic app scaling within an AKS environment."),(0,i.kt)("p",null,"The cluster autoscaler ensures our cluster scales its resources intelligently based on workload demand. It optimizes cost-effectiveness by adding or removing nodes dynamically, thus efficiently managing resources."),(0,i.kt)("p",null,"The HPA complements this by automatically scaling individual Pods within the cluster, monitoring metrics like CPU usage or custom metrics and adjusting the number of running pods to match application demand."),(0,i.kt)("p",null,"To understand how these two concepts work seamlessly to provide a comprehensive scaling solution, let\u2019s now get into the details of cluster autoscaler configuration. Later, we\u2019ll discuss how to set up HPA in our AKS cluster."),(0,i.kt)("h5",{id:"setting-up-the-cluster-autoscaler-in-aks"},"Setting Up the Cluster Autoscaler in AKS"),(0,i.kt)("p",null,"Setting up the cluster autoscaler in AKS involves a combination of Azure CLI and kubectl commands. Here\u2019s a step-by-step guide to help you through the process, including initial setup, configuring minimum and maximum node counts per node pool, and monitoring the cluster autoscaler\u2019s performance."),(0,i.kt)("p",null,"To follow along, ensure you\u2019re logged in to your Azure account. To log in, run the following command in your terminal:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"az login\n")),(0,i.kt)("p",null,"In the first part of this series, we created an AKS cluster named ",(0,i.kt)("inlineCode",{parentName:"p"},"aks-intelligent-app"),". The picture below shows that AKS creates a single node pool named ",(0,i.kt)("inlineCode",{parentName:"p"},"nodepool1")," by default. We can access the AKS cluster nodes and visualize the default ",(0,i.kt)("inlineCode",{parentName:"p"},"nodepool1")," by clicking the ",(0,i.kt)("strong",{parentName:"p"},"Node pools")," menu in the ",(0,i.kt)("strong",{parentName:"p"},"Settings")," section:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"image of node pools in Azure portal",src:a(19711).Z,width:"624",height:"179"})),(0,i.kt)("p",null,"In the image above, \u201cNode count: 1/1 ready\u201d indicates that we have one virtual machine (node) allocated in the node pool ",(0,i.kt)("inlineCode",{parentName:"p"},"nodepool1")," within our AKS cluster. That node is currently healthy and operational, meaning it\u2019s ready to accept and execute workloads."),(0,i.kt)("p",null,"In the context of an AKS cluster, a node pool is a set of virtual machines with similar configurations and capacities. These node pools are distinct virtual machine (VM) groups forming the cluster\u2019s computing resources. Node pools allow for workload segregation and resource allocation optimization, as we can tailor each pool to handle specific tasks or workloads. This modular approach enhances flexibility and resource management within the AKS cluster."),(0,i.kt)("p",null,"Using kubectl, retrieve information on the current nodes by running the command below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"kubectl get nodes \n")),(0,i.kt)("p",null,"This command above should retrieve results similar to those below:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"NAME"),(0,i.kt)("th",{parentName:"tr",align:"left"},"STATUS"),(0,i.kt)("th",{parentName:"tr",align:"left"},"ROLES"),(0,i.kt)("th",{parentName:"tr",align:"left"},"AGE"),(0,i.kt)("th",{parentName:"tr",align:"left"},"VERSION"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"aks-nodepool1-27122202-vmss000000"),(0,i.kt)("td",{parentName:"tr",align:"left"},"Ready"),(0,i.kt)("td",{parentName:"tr",align:"left"},"agent"),(0,i.kt)("td",{parentName:"tr",align:"left"},"59m"),(0,i.kt)("td",{parentName:"tr",align:"left"},"v1.26.6")))),(0,i.kt)("p",null,"Let\u2019s say we want our app to support more than one node. In this case, we have two options: customize ",(0,i.kt)("inlineCode",{parentName:"p"},"nodepool1")," or add more node pools as needed. In this guide, we\u2019ll review how to update the existing ",(0,i.kt)("inlineCode",{parentName:"p"},"nodepool1")," node pool to support multiple nodes. "),(0,i.kt)("p",null,"Run the following command in your terminal to update the existing node pool:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"az aks update --resource-group computer-vision --name aks-intelligent-app --enable-cluster-autoscaler --min-count 2 --max-count 3\n")),(0,i.kt)("p",null,"This change ensures the node pool will always have at least two nodes available and can scale up to a maximum of three nodes, depending on the workload demand. This approach helps manage resource allocation based on varying needs within the AKS cluster."),(0,i.kt)("p",null,"Now, run the ",(0,i.kt)("inlineCode",{parentName:"p"},"kubectl")," get nodes command again to retrieve the new node count:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"kubectl get nodes\n")),(0,i.kt)("p",null,"Your results should appear similar to those below:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"NAME"),(0,i.kt)("th",{parentName:"tr",align:"left"},"STATUS"),(0,i.kt)("th",{parentName:"tr",align:"left"},"ROLES"),(0,i.kt)("th",{parentName:"tr",align:"left"},"AGE"),(0,i.kt)("th",{parentName:"tr",align:"left"},"VERSION"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"aks-nodepool1-27122202-vmss000000"),(0,i.kt)("td",{parentName:"tr",align:"left"},"Ready"),(0,i.kt)("td",{parentName:"tr",align:"left"},"agent"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2d5h"),(0,i.kt)("td",{parentName:"tr",align:"left"},"v1.26.6")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"aks-nodepool1-27122202-vmss000001"),(0,i.kt)("td",{parentName:"tr",align:"left"},"Ready"),(0,i.kt)("td",{parentName:"tr",align:"left"},"agent"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2d54"),(0,i.kt)("td",{parentName:"tr",align:"left"},"v1.26.6")))),(0,i.kt)("p",null,"Refresh the ",(0,i.kt)("strong",{parentName:"p"},"Node pools")," page of your ",(0,i.kt)("inlineCode",{parentName:"p"},"aks-intelligent-app")," AKS cluster in the Azure Portal: "),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"image of refreshed node pools in Azure portal",src:a(1544).Z,width:"624",height:"179"})),(0,i.kt)("p",null,"The \u201cNode count: 2/2 ready\u201d above indicates that you now have two nodes allocated, both in a healthy and operational state."),(0,i.kt)("p",null,"To view more information about the node in your cluster, select the ",(0,i.kt)("strong",{parentName:"p"},"Nodes")," tab on the ",(0,i.kt)("strong",{parentName:"p"},"Node pools")," page:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"image of nodes tab results in Azure portal",src:a(58394).Z,width:"624",height:"215"})),(0,i.kt)("p",null,"Here, the CPU, memory, disks, and Pods information provide a comprehensive view of the cluster\u2019s resource utilization and workload distribution."),(0,i.kt)("h5",{id:"how-the-cluster-autoscaler-dynamically-scales-resources"},"How the Cluster Autoscaler Dynamically Scales Resources"),(0,i.kt)("p",null,"The cluster autoscaler is pivotal in maintaining the optimal performance and cost-effectiveness of Intelligent Apps within cloud environments."),(0,i.kt)("p",null,"The cluster autoscaler in AKS continuously monitors the cluster\u2019s resource use, including CPU and memory, and compares it to the resource requests and limits defined in the Pod specifications. When the autoscaler detects that additional resources are required to meet the workloads\u2019 demands, it automatically provisions new nodes, expanding the cluster\u2019s capacity. Conversely, when there\u2019s a decrease in resource demands, the cluster autoscaler scales in by removing underused nodes, optimizing cost efficiency."),(0,i.kt)("p",null,"By dynamically scaling resources in response to fluctuations in workload demand, the autoscaler ensures they are efficiently allocated, preventing overprovisioning during periods of low activity and scaling up when demand peaks. This adaptive approach enhances the responsiveness of Intelligent Apps and mitigates unnecessary expenses by rightsizing the infrastructure."),(0,i.kt)("h5",{id:"configuring-the-horizontal-pod-autoscaler"},"Configuring the Horizontal Pod Autoscaler"),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/"},"Kubernetes HorizontalPodAutoscaler")," (HPA) is a powerful tool that ensures optimal application performance and resource use. It dynamically adjusts the number of running pods in a Kubernetes deployment based on either CPU usage, memory usage or custom metrics defined by the user."),(0,i.kt)("p",null,"To configure it, we must first define the desired target for resource use. For instance, if using a CPU, we\u2019d specify a target percentage of CPU usage per Pod. Once we set the target, the HPA constantly monitors the metrics and automatically scales the number of Pods to maintain the desired use level."),(0,i.kt)("p",null,"To demonstrate what HPA can do, let\u2019s write a YAML file and configure it to work with our Intelligent App. Create a file named ",(0,i.kt)("inlineCode",{parentName:"p"},"intelligent-app-hpa.yml")," in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Deployment")," folder with the following contents:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"apiVersion: autoscaling/v1 \nkind: HorizontalPodAutoscaler \nmetadata: \n  name: intelligent-app-hpa \nspec: \n  maxReplicas: 10 \n  minReplicas: 3 \n  scaleTargetRef: \n    apiVersion: apps/v1 \n    kind: Deployment \n    name: intelligent-app \n  targetCPUUtilizationPercentage: 50 \n")),(0,i.kt)("p",null,"Note: You can also enable pod autoscaling but including the spec above in your pod definition yaml file."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"intelligent-app-hpa.yml")," file above defines an HPA resource in Kubernetes. It configures the autoscaler for the ",(0,i.kt)("inlineCode",{parentName:"p"},"intelligent-app")," Deployment to automatically adjust the number of replicas (Pods) based on CPU usage. The HPA ensures the number of replicas ranges from a minimum of 3 to a maximum of 10, targeting a CPU use of 50 percent."),(0,i.kt)("p",null,"As the CPU usage changes, the HPA automatically scales the number of replicas to maintain the desired CPU use level. This process allows the ",(0,i.kt)("inlineCode",{parentName:"p"},"intelligent-app")," Deployment to handle varying workloads efficiently while staying within specified resource boundaries."),(0,i.kt)("p",null,"To apply HPA, change the terminal to the deployment folder and run the ",(0,i.kt)("inlineCode",{parentName:"p"},"kubectl")," command below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"cd Deployment\nkubectl apply -f intelligent-app-hpa.yml\n")),(0,i.kt)("p",null,"This command applies the configuration described in the ",(0,i.kt)("inlineCode",{parentName:"p"},"intelligent-app-hpa.yml")," file to create an HPA resource within the Kubernetes cluster."),(0,i.kt)("p",null,"To review the created HPA resource in your terminal, run the following command:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"kubectl get hpa\n")),(0,i.kt)("p",null,"The terminal will display information about the HPA resources present in the Kubernetes cluster, providing details including target deployments, desired replicas, current replicas, and usage metrics for autoscaling:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"NAME"),(0,i.kt)("th",{parentName:"tr",align:"left"},"REFERENCE"),(0,i.kt)("th",{parentName:"tr",align:"left"},"TARGETS"),(0,i.kt)("th",{parentName:"tr",align:"left"},"MINPODS"),(0,i.kt)("th",{parentName:"tr",align:"left"},"MAXPODS"),(0,i.kt)("th",{parentName:"tr",align:"left"},"REPLICAS"),(0,i.kt)("th",{parentName:"tr",align:"left"},"AGE"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"intelligent-app-hpa"),(0,i.kt)("td",{parentName:"tr",align:"left"},"Deployment/intelligent-app"),(0,i.kt)("td",{parentName:"tr",align:"left"},"1%/50%"),(0,i.kt)("td",{parentName:"tr",align:"left"},"3"),(0,i.kt)("td",{parentName:"tr",align:"left"},"10"),(0,i.kt)("td",{parentName:"tr",align:"left"},"3"),(0,i.kt)("td",{parentName:"tr",align:"left"},"36s")))),(0,i.kt)("p",null,"As we can see in the results, the ",(0,i.kt)("inlineCode",{parentName:"p"},"HorizontalPodAutoscaler")," resource is linked to the ",(0,i.kt)("inlineCode",{parentName:"p"},"intelligent-app")," Deployment. The \u201c1%/50%\u201d indicates that the current CPU use is 1 percent of the target use of 50 percent. The HPA maintains a minimum of 3 replicas (Pods) and can scale up to a maximum of 10 replicas. Currently, only three replicas are running."),(0,i.kt)("h4",{id:"ensuring-high-availability-with-azure-load-balancer-and-aks"},"Ensuring High Availability with Azure Load Balancer and AKS"),(0,i.kt)("p",null,"We can configure and manage Azure Load Balancer, availability zones (AZs), and Pod disruption budgets to ensure high availability in our application. In this section, we cover these concepts in detail."),(0,i.kt)("p",null,"In the first article of this series, we learned we can run the ",(0,i.kt)("inlineCode",{parentName:"p"},"kubectl get services")," command to list the services and their corresponding details, such as the Service name, cluster IP address, external IP, and ports."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"kubectl get services")," command offers a quick and comprehensive snapshot of the services deployed within your Kubernetes cluster, providing key details such as service names, cluster IPs, external IPs, ports, and associated endpoints. This information enables administrators and developers to monitor, troubleshoot, and manage the connectivity and accessibility of services."),(0,i.kt)("p",null,"Run this command in your terminal: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"kubectl get services\n")),(0,i.kt)("p",null,"You should receive an output similar to the following:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"NAME"),(0,i.kt)("th",{parentName:"tr",align:"left"},"TYPE"),(0,i.kt)("th",{parentName:"tr",align:"left"},"CLUSTER-IP"),(0,i.kt)("th",{parentName:"tr",align:"left"},"EXTERNAL-IP"),(0,i.kt)("th",{parentName:"tr",align:"left"},"PORT(S)"),(0,i.kt)("th",{parentName:"tr",align:"left"},"AGE"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"intelligent-app-service"),(0,i.kt)("td",{parentName:"tr",align:"left"},"LoadBalancer"),(0,i.kt)("td",{parentName:"tr",align:"left"},"10.0.77.60"),(0,i.kt)("td",{parentName:"tr",align:"left"},"20.121.76.153"),(0,i.kt)("td",{parentName:"tr",align:"left"},"80:30936/TCP"),(0,i.kt)("td",{parentName:"tr",align:"left"},"47s")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"kubernetes"),(0,i.kt)("td",{parentName:"tr",align:"left"},"ClusterIP"),(0,i.kt)("td",{parentName:"tr",align:"left"},"10.0.0.1"),(0,i.kt)("td",{parentName:"tr",align:"left"},"<","none",">"),(0,i.kt)("td",{parentName:"tr",align:"left"},"443/TCP"),(0,i.kt)("td",{parentName:"tr",align:"left"},"14m")))),(0,i.kt)("p",null,"In this output, we can see a Kubernetes Service named ",(0,i.kt)("inlineCode",{parentName:"p"},"intelligent-app-service")," with a type of ",(0,i.kt)("inlineCode",{parentName:"p"},"LoadBalancer"),", reachable from the cluster through the IP ",(0,i.kt)("inlineCode",{parentName:"p"},"10.0.77.60"),". It\u2019s accessible via ",(0,i.kt)("inlineCode",{parentName:"p"},"20.121.76.153")," on port 80, mapped to port 30936."),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/azure/load-balancer/load-balancer-overview?WT.mc_id=javascript-99907-ninarasi"},"Azure Load Balancer")," continuously monitors the health and responsiveness of each Pod or node and actively distributes incoming requests to maintain a balanced load across pods. It ensures even traffic distribution among the Pods, preventing any one Pod or node from becoming overwhelmed and promoting optimal resource use."),(0,i.kt)("p",null,"The Load Balancer\u2019s ability to intelligently route requests to healthy Pods, combined with the service\u2019s configuration for ",(0,i.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/"},"health probes")," and backend pool setup, promotes the high availability and responsiveness of the application."),(0,i.kt)("p",null,"These features allow it to adapt seamlessly to varying workloads and potential node failures while delivering a reliable user experience."),(0,i.kt)("h5",{id:"availability-zones-in-aks"},"Availability Zones in AKS"),(0,i.kt)("p",null,"Azure AZs are crucial in enhancing the resilience and availability of applications within AKS. Deploying AKS clusters across multiple AZs involves distributing cluster resources across physically isolated data centers. This approach ensures that if one zone experiences an outage, perhaps due to a natural disaster in that region, the application can continue operating from another."),(0,i.kt)("p",null,"In the first article, we created an AKS cluster. Now, we can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"kubectl")," command and ",(0,i.kt)("inlineCode",{parentName:"p"},"grep")," to check the AZs for nodes in this AKS cluster. Run this command in your terminal:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'kubectl get nodes -o custom-columns="NAME:.metadata.name,AVAILABILITY_ZONE:.metadata.labels.topology\\.kubernetes\\.io/zone"\n')),(0,i.kt)("p",null,"You should receive results similar to those below:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"NAME"),(0,i.kt)("th",{parentName:"tr",align:"left"},"AVAILABILITY_ZONE"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"aks-nodepool1-57155478-vmss000001"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0")))),(0,i.kt)("p",null,"The output shows that the node ",(0,i.kt)("inlineCode",{parentName:"p"},"aks-nodepool1-57155478-vmss000001")," is in availability zone 0. This information helps us understand how Kubernetes distributes the nodes in the cluster across AZs\u2014vital for achieving high availability and fault tolerance in our Kubernetes-based applications."),(0,i.kt)("p",null,"Notably, after we create our AKS cluster, we cannot directly modify it to enable or disable AZs. To create a cluster that works across AZs 1, 2, and 3, modify the ",(0,i.kt)("inlineCode",{parentName:"p"},"az aks")," create command as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"az aks create --resource-group computer-vision --name aks-intelligent-app --node-count 1 --generate-ssh-keys --zones 1 2 3\n")),(0,i.kt)("p",null,"Note: We can discover the AZs in Azure for a specific region using the Azure CLI. Open your command-line terminal and run the following command to list the available AZs for a specific Azure region:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"az vm list-skus --location <region-name> --output table\n")),(0,i.kt)("p",null,"Replace ",(0,i.kt)("inlineCode",{parentName:"p"},"<region-name>")," with the name of the Azure region you want to check. For example, if you want to check AZs for the East US region:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"az vm list-skus --location eastus --output table\n")),(0,i.kt)("h5",{id:"maintaining-service-during-voluntary-disruptions-using-disruption-budgets"},"Maintaining Service During Voluntary Disruptions Using Disruption Budgets"),(0,i.kt)("p",null,"In AKS, ",(0,i.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/azure/aks/operator-best-practices-scheduler#voluntary-disruptions"},"Pod disruption budgets")," (PDBs) are critical in maintaining service availability during updates or planned disruptions. PDBs set guidelines for how many Pods can be unavailable simultaneously, preventing excessive downtime by ensuring that only a controlled number of Pods are taken offline at any given time. This design lets us maintain service during voluntary disruptions."),(0,i.kt)("p",null,"Here\u2019s a step-by-step guide on creating and managing PDBs where we define a minimum available or maximum unavailable resource count."),(0,i.kt)("p",null,"To create a PDB, you will define a YAML configuration file that specifies the desired criteria for your budget. First, create a file named ",(0,i.kt)("inlineCode",{parentName:"p"},"pdb-config.yml")," in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Deployment")," folder with the following contents: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"apiVersion: policy/v1\nkind: PodDisruptionBudget\nmetadata:\n   name: intelligent-app\nspec:\n   minAvailable: 3\n   selector:\n    matchLabels:\n      app: intelligent-app\n")),(0,i.kt)("p",null,"Here, the ",(0,i.kt)("inlineCode",{parentName:"p"},"minAvailable")," field specifies the minimum number of Pods that must remain available (not disrupted or terminated) during voluntary disruptions like maintenance or updates. Setting this field to ",(0,i.kt)("inlineCode",{parentName:"p"},"3")," means that when disruptions occur, Kubernetes will ensure that at least three Pods of the specified application are running at all times."),(0,i.kt)("p",null,"Now, ensure you are in the Deployment folder and apply the PDB configuration using the ",(0,i.kt)("inlineCode",{parentName:"p"},"kubectl")," apply command:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"kubectl apply -f pdb-config.yml\n")),(0,i.kt)("p",null,"To verify that you\u2019ve successfully created the PDB, run the following command:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"kubectl describe pdb intelligent-app\n")),(0,i.kt)("p",null,"This command will give you the following results:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Name:           intelligent-app \nNamespace:      default \nMin available:  3 \nSelector:       app=intelligent-app \nStatus: \n    Allowed disruptions:  0 \n    Current:              1 \n    Desired:              3 \n    Total:                1 \nEvents:                   <none> \n")),(0,i.kt)("p",null,"Now let\u2019s analyze the output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Name and namespace"),"\u2014The PDB is named \u201cintelligent-app\u201d and belongs to the \u201cdefault\u201d namespace. "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Min available"),"\u2014The PDB specifies that at least three Pods must always be available. So, even during planned disruptions, there will always be at least three application Pods running. "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Selector"),"\u2014The PDB applies to Pods labeled ",(0,i.kt)("inlineCode",{parentName:"li"},"app=intelligent-app"),". "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Status")," \u2014",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Allowed disruptions"),"\u2014The value 0 means that the PDB doesn\u2019t allow any disruptions or evictions of Pods that match its selector. In this example, it ensures that at least three healthy Pods are always available and no disruptions are permitted."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Current"),"\u2014Shows the current number of available healthy replicas that match the PDB\u2019s selector. In this case, it\u2019s 1, meaning there is currently one healthy Pod."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Desired"),"\u2014Indicates the desired number of replicas that should be available. It\u2019s also set to 3, meaning the PDB wants to maintain three replicas."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Total"),"\u2014The total number of replicas matching the PDB's selector. It\u2019s 1, indicating that there is one replica."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Events"),"\u2014The ",(0,i.kt)("inlineCode",{parentName:"li"},"<none>")," entry under ",(0,i.kt)("inlineCode",{parentName:"li"},"Events")," indicates no recent events or changes associated with this PDB.")),(0,i.kt)("p",null,"By implementing these budgets, AKS ensures a gradual and controlled update process, minimizing service disruption and providing a reliable user experience. It\u2019s a strategic approach to balance necessary updates with keeping the service responsive and available to users."),(0,i.kt)("h5",{id:"configuring-azure-load-balancer-in-aks-for-high-availability"},"Configuring Azure Load Balancer in AKS for High Availability"),(0,i.kt)("p",null,"To ensure that your applications can withstand failures and maintain continuous service availability, you must configure the Azure Load Balancer in AKS for high availability. You can take many measures to increase Azure Load Balancer\u2019s availability in your AKS cluster."),(0,i.kt)("p",null,"To demonstrate, open your terminal and run the following command:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"az aks update --resource-group computer-vision --name aks-intelligent-app --load-balancer-managed-outbound-ip-count 2 \n")),(0,i.kt)("p",null,"The Azure CLI command above updates the ",(0,i.kt)("inlineCode",{parentName:"p"},"aks-intelligent-app")," AKS cluster, setting the managed outbound IP count for the cluster\u2019s load balancer to 2. This command increases the number of managed outbound IPs associated with the cluster\u2019s load balancer, which can be helpful where multiple outbound IP addresses are required for load balancing and network egress, improving the cluster\u2019s networking capabilities and allowing for more flexible outbound traffic management.  "),(0,i.kt)("p",null,"To configure Azure Load Balancer in AKS for high availability, consider implementing the following additional measures: "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Use Azure AZs"),"\u2014Deploy your AKS cluster across multiple ",(0,i.kt)("a",{parentName:"li",href:"https://azure.microsoft.com/explore/global-infrastructure/availability-zones?WT.mc_id=javascript-99907-ninarasi"},"Azure AZs")," to ensure redundancy and fault tolerance."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Configure health probes"),"\u2014Define ",(0,i.kt)("a",{parentName:"li",href:"https://learn.microsoft.com/azure/load-balancer/load-balancer-custom-probe-overview?WT.mc_id=javascript-99907-ninarasi"},"health probes")," for your Azure Load Balancer to regularly check the health of backend pods or nodes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Load Balancer rules"),"\u2014Configure ",(0,i.kt)("a",{parentName:"li",href:"https://learn.microsoft.com/azure/load-balancer/manage-rules-how-to?WT.mc_id=javascript-99907-ninarasi"},"load balancing rules")," to distribute traffic efficiently."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Backend pool scaling"),"\u2014Adjust the ",(0,i.kt)("a",{parentName:"li",href:"https://learn.microsoft.com/azure/load-balancer/backend-pool-management?WT.mc_id=javascript-99907-ninarasi"},"backend pool scaling")," based on traffic patter"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Network security rules"),"\u2014Implement ",(0,i.kt)("a",{parentName:"li",href:"https://learn.microsoft.com/security/benchmark/azure/baselines/azure-load-balancer-security-baseline?WT.mc_id=javascript-99907-ninarasi"},"network security groups (NSGs)")," to control inbound and outbound traffic to and from the Load Balancer."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Azure monitoring and diagnostics"),"\u2014Set up ",(0,i.kt)("a",{parentName:"li",href:"https://learn.microsoft.com/azure/aks/monitor-aks?WT.mc_id=javascript-99907-ninarasi"},"monitoring and diagnostics")," to gain insights into the Load Balancer\u2019s performance and traffic distribution."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Backup and Recovery"),"\u2014Implement ",(0,i.kt)("a",{parentName:"li",href:"https://learn.microsoft.com/azure/backup/azure-kubernetes-service-backup-overview?WT.mc_id=javascript-99907-ninarasi"},"backup and disaster recovery")," strategies for your AKS cluster and Load Balancer configurations."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Scaling and autoscaling"),"\u2014Use ",(0,i.kt)("a",{parentName:"li",href:"https://learn.microsoft.com/azure/aks/concepts-scale?WT.mc_id=javascript-99907-ninarasi"},"AKS horizontal Pod autoscaling")," for your applications to adjust the number of pods automatically based on resource usage.")),(0,i.kt)("p",null,"You can ",(0,i.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/azure/aks/load-balancer-standard?WT.mc_id=javascript-99907-ninarasi"},"explore this topic further")," on Microsoft Learn. "),(0,i.kt)("h2",{id:"exercise"},"Exercise"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Complete this ",(0,i.kt)("strong",{parentName:"li"},"hands-on sample")," ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/contentlab-io/Microsoft-Using-Azure-Kubernetes-Service-to-Deploy-an-Intelligent-App-for-Analyzing-Images-3/tree/main/Microsoft_21_Code/Deployment"},"project code")," to scale and monitor your intelligent app on AKS"),(0,i.kt)("li",{parentName:"ul"},"Register for the ",(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("a",{parentName:"strong",href:"https://learn.microsoft.com/en-us/events/learn-events/learnlive-intelligent-apps-with-azure-kubernetes-service/?WT.mc_id=javascript-99907-ninarasi"},"Learn Live: Kubernetes Edition"))," starting Oct 12 - a live SME guided walkthrough on a reference architecture to build intelligent apps with AKS and Azure Open AI"),(0,i.kt)("li",{parentName:"ul"},"Register for ",(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("a",{parentName:"strong",href:"https://reactor.microsoft.com/en-us/reactor/series/S-1037/"},"Ask the Expert: Azure Kubernetes Service"))," session for live Q&A with the Product Engineering team on building intelligent serverless apps.")),(0,i.kt)("h2",{id:"next-steps"},"Next Steps"),(0,i.kt)("p",null,"In the ",(0,i.kt)("a",{parentName:"p",href:"https://azure.github.io/Cloud-Native/30daysofIA/scaling-intelligent-apps-on-azure-kubernetes-services-2"},"next blog"),", continue exploring monitoring Azure Kubernetes Service clusters and deep dive into real world uses cases for scaling and designing high availability in intelligent apps."))}c.isMDXComponent=!0},90615:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/blog-image-2-5-1-4fa8cc4a31e772d8316415e09e1aca46.jpg"},19711:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/blog-image-2-5-2-1416ed05e85ba3331e8fc828df06d82d.png"},1544:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/blog-image-2-5-3-21bab172d266de4714b2e522f1bbc124.png"},58394:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/blog-image-2-5-4-a6847a5ee50feb961551e20bebff6228.png"},17325:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/blog-image-2-5-sa-9917e8a07e6469d673689f859dfe6e7a.png"}}]);